
# 2.a Алгоритм Евклида (поиск наибольшего общего делителя)

def gcd(a, b):
    """
    Функция для нахождения наибольшего общего делителя (НОД) двух чисел.
    Используется алгоритм Евклида.
    """
    while b != 0:
        a, b = b, a % b
    return a

def euclidean_algorithm():
    """
    Задачи, связанные с нахождением НОД с использованием алгоритма Евклида.
    """

    print("2.a Алгоритм Евклида (НОД):")

    # 1) gcd(67, 14)
    print("1) gcd(67, 14) =", gcd(67, 14))  # Ожидаемый результат: 1

    # 2) gcd(-67, 14)
    # Алгоритм Евклида работает для отрицательных чисел, поскольку НОД всегда положителен.
    print("2) gcd(-67, 14) =", gcd(-67, 14))  # Ожидаемый результат: 1

    # 3) gcd(261, 233)
    print("3) gcd(261, 233) =", gcd(261, 233))  # Ожидаемый результат: 1

    # 4) gcd(225, 0)
    # НОД числа с 0 всегда равно числу, которое не равно нулю.
    print("4) gcd(225, 0) =", gcd(225, 0))  # Ожидаемый результат: 225

    # 5) gcd(999999, 1000000)
    print("5) gcd(999999, 1000000) =", gcd(999999, 1000000))  # Ожидаемый результат: 1

    # 6) gcd(n, n), для n ∈ Z
    # НОД числа с самим собой всегда равно этому числу.
    print("6) gcd(7, 7) =", gcd(7, 7))  # Ожидаемый результат: 7

    # 7) gcd(n, n + 1), для n ∈ Z
    # НОД любого числа и его последующего всегда равен 1.
    print("7) gcd(7, 8) =", gcd(7, 8))  # Ожидаемый результат: 1

    # 8) gcd(35452, 30952)
    print("8) gcd(35452, 30952) =", gcd(35452, 30952))  # Ожидаемый результат: 2

    # 9) gcd(2^2 ⋅ 7^21 ⋅ 112 ⋅ 2310, 3^4 ⋅ 5^25 ⋅ 7^3 ⋅ 1118)
    # Это сложное выражение, но мы можем вычислить НОД для таких чисел.
    # Предположим, что выражения уже вычислены.
    print("9) gcd(2^2 * 7^21 * 112 * 2310, 3^4 * 5^25 * 7^3 * 1118) =", gcd(2**2 * 7**21 * 112 * 2310, 3**4 * 5**25 * 7**3 * 1118))  # Ожидаемый результат: НОД для этих чисел

    # 10) gcd(7524, 6120, 4626, 1395)
    # Используем пошаговое вычисление НОД для четырех чисел.
    nums = [7524, 6120, 4626, 1395]
    result = nums[0]
    for num in nums[1:]:
        result = gcd(result, num)
    print("10) gcd(7524, 6120, 4626, 1395) =", result)  # Ожидаемый результат: НОД для этих чисел


# 2.b Расширенный алгоритм Евклида (нахождение обратных элементов)

def extended_gcd(a, b):
    """
    Расширенный алгоритм Евклида.
    Возвращает НОД a и b, а также коэффициенты x и y такие, что:
    ax + by = gcd(a, b)
    """
    if b == 0:
        return a, 1, 0
    else:
        gcd_value, x1, y1 = extended_gcd(b, a % b)
        x = y1
        y = x1 - (a // b) * y1
        return gcd_value, x, y

def extended_euclidean_algorithm():
    """
    Задачи, связанные с использованием расширенного алгоритма Евклида.
    """

    print("\n2.b Расширенный алгоритм Евклида:")

    # 1) x = 3^(-1) mod 14
    # Нужно найти обратное число 3 по модулю 14.
    gcd_value, x, _ = extended_gcd(3, 14)
    if gcd_value == 1:
        print("1) 3^(-1) mod 14 =", x % 14)  # Ожидаемый результат: 5
    else:
        print("1) 3^(-1) mod 14 не существует")

    # 2) 261x + 233y = gcd(261, 233)
    gcd_value, x, y = extended_gcd(261, 233)
    print("2) 261x + 233y =", gcd_value, "где x =", x, "и y =", y)

    # 3) 261x ≡ 11 (mod 233)
    # Решаем линейное конгруэнтное уравнение.
    gcd_value, x, _ = extended_gcd(261, 233)
    if gcd_value == 1:
        solution = (x * 11) % 233
        print("3) 261x ≡ 11 (mod 233) -> x =", solution)  # Ожидаемый результат: решение для x

    # 4) x = 261^(-1) mod 233
    gcd_value, x, _ = extended_gcd(261, 233)
    if gcd_value == 1:
        print("4) 261^(-1) mod 233 =", x % 233)  # Ожидаемый результат: 98
    else:
        print("4) 261^(-1) mod 233 не существует")

    # 5) 119x + 567y = gcd(119, 567)
    gcd_value, x, y = extended_gcd(119, 567)
    print("5) 119x + 567y =", gcd_value, "где x =", x, "и y =", y)

    # 6) 119x ≡ 35 (mod 567)
    gcd_value, x, _ = extended_gcd(119, 567)
    if gcd_value == 1:
        solution = (x * 35) % 567
        print("6) 119x ≡ 35 (mod 567) -> x =", solution)  # Ожидаемый результат: решение для x

    # 7) x = 119^(-1) mod 567
    gcd_value, x, _ = extended_gcd(119, 567)
    if gcd_value == 1:
        print("7) 119^(-1) mod 567 =", x % 567)  # Ожидаемый результат: 442
    else:
        print("7) 119^(-1) mod 567 не существует")

    # 8) x = (n - 1)^(-1) mod n, где n > 1
    # Для любого числа n, мы ищем обратное число (n-1) по модулю n.
    n = 11  # Пример для n = 11
    gcd_value, x, _ = extended_gcd(n - 1, n)
    if gcd_value == 1:
        print("8) (n - 1)^(-1) mod n =", x % n)  # Ожидаемый результат: 10 для n = 11
    else:
        print("8) (n - 1)^(-1) mod n не существует")

if __name__ == "__main__":
    # Вызов функций для выполнения задач
    euclidean_algorithm()
    extended_euclidean_algorithm()
